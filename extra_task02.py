# Единичная дробь имеет 1 в числителе. Десятичные представления единичных дробей со 
# знаменателями от 2 до 10 даны ниже:

# 1/2=0.5
# 1/3=0.(3)
# 1/4=0.25
# 1/5=0.2
# 1/6=0.1(6)
# 1/7=0.(142857)
# 1/8=0.125
# 1/9=0.(1)
# 1/10=0.1
# Где 0.1(6) значит 0.166666..., и имеет повторяющуюся последовательность из одной цифры. 
# Заметим, что 1/7 имеет повторяющуюся последовательность из 6 цифр.

# Найдите значение d < 1000, для которого 1/d в десятичном виде содержит самую длинную
#  повторяющуюся последовательность цифр.


# Очень долго не удавалось решить
# Только динамическим программированием решить не удалось. Пришлось использовать RegExp-ы
# Наверняка можно с помощью ДП сделать, но пока не знаю как (((
import re
from itertools import groupby

def MyFindAll(text): # Ищем вхождения повторяющихся строк (возвращаяем повторяющуюся субстроку)
#    ret = re.findall(r'((\w+)\2+)', text, flags=0)
    ret = max(re.findall(r'((\w+)\2+)', text, flags=0), key= len, default='')
    if ret== '': return ''
    return ret[1]

def RP3(text):  # Почему то re.findall не всегда выдает только повторяющуюся последовательность
    tmp2 = text # потому - его приходится запускать несколько раз (чтобы он эту последовательность дочистил)
    tmp1 = tmp2
    while tmp2 != '':
        tmp1 = tmp2
        tmp2 = MyFindAll(tmp1)
    return tmp1

def MyFind(n): # Тут ищем последовательности с помощью словаря
    ret = {len(RP3(format(1/i,".55"))):i for i in range(2,n)}
    return ret[max([key for key in ret.items()])[0]]

findNUM = MyFind(1000)
print(f'1/{findNUM} = {format(1/findNUM,".55")}, repeat = {RP3(format(1/findNUM,".55"))}')
